package cli

import (
	"bytes"
	"path/filepath"
	"testing"

	"github.com/dexterp/ifaces/internal/resources/testtools/testpaths"

	"github.com/stretchr/testify/assert"
)

var (
	pre            = `PreIface`
	post           = `PostIface`
	pkg            = "mypkg"
	file           = "mypkg.go"
	out            = "src_ifaces.go"
	comment        = "DO NOT EDIT. This file has been generated"
	commentDefault = `DO NOT EDIT. GENERATED BY ifaces`
	wild           = "*MyStruct*"
	stdout         = &bytes.Buffer{}
	stderr         = &bytes.Buffer{}
)

func TestParseArgs_Gen_Manditory(t *testing.T) {
	scanfile := "internal/resources/parser/parser.go"
	cmd := []string{"ifaces", "gen", out, "-f", scanfile}
	args, err := ParseArgs(cmd[1:], ``, stdout, stderr)
	if err != nil {
		t.Error(err)
		t.FailNow()
	}
	assert.True(t, args.Gen)
	assert.Equal(t, commentDefault, args.Cmt)
	if len(args.Srcs) > 0 {
		assert.Equal(t, scanfile, args.Srcs[0])
	} else {
		t.Fail()
	}
	assert.Zero(t, stdout.String())
	assert.Zero(t, stderr.String())
}

func TestParseArgs_Head_Manditory(t *testing.T) {
	cmd := []string{"ifaces", "head", "src_ifaces.go"}
	args, err := ParseArgs(cmd[1:], ``, stdout, stderr)
	if err != nil {
		t.Fail()
	}
	assert.True(t, args.Head, `args.Head not set`)
	assert.False(t, args.Append, `args.Append should not be set`)
	assert.Equal(t, ``, args.Pre, `args.Pre should be empty`)
	assert.Equal(t, ``, args.Post, `args.Post should be empty`)
	assert.Equal(t, commentDefault, args.Cmt, `args.Cmt ishould be empty`)
	assert.Equal(t, ``, args.Wild, `args.Wild should be empty`)
	assert.Equal(t, `cli`, args.Pkg, `args.Pkg set dynamically`)
	assert.Zero(t, stdout.String())
	assert.Zero(t, stderr.String())
}

func TestParseArgs_Head_Optional(t *testing.T) {
	generatedsrc := filepath.Join(testpaths.TempDir(), pkg, file)
	pkg = `otherpkg`
	cmd := []string{"ifaces", "head", generatedsrc, "-p", pkg, "-a", "--pre", pre, "--post", post, "-c", comment, "-w", wild, "--print"}
	args, err := ParseArgs(cmd[1:], ``, stdout, stderr)
	if err != nil {
		t.Fail()
	}
	assert.True(t, args.Head, `args.Head not set`)
	assert.True(t, args.Append, `args.Append not set`)
	assert.Equal(t, pre, args.Pre, `args.Pre incorrect`)
	assert.Equal(t, post, args.Post, `args.Post incorrect`)
	assert.Equal(t, comment, args.Cmt, `args.Cmt incorrect`)
	assert.Equal(t, wild, args.Wild, `args.Wild incorrect`)
	assert.Equal(t, pkg, args.Pkg, `args.Pkg incorrect`)
	assert.True(t, args.Print, `args.Print not set`)
	assert.Zero(t, stdout.String())
	assert.Zero(t, stderr.String())
}

func TestParseArgs_Head_OptionalDynamicPkg(t *testing.T) {
	generatedsrc := filepath.Join(testpaths.TempDir(), pkg, file)
	cmd := []string{"ifaces", "head", generatedsrc, "-a", "--pre", pre, "--post", post, "-c", comment, "-w", wild}
	args, err := ParseArgs(cmd[1:], ``, stdout, stderr)
	if err != nil {
		t.Fail()
	}
	assert.True(t, args.Head, `args.Head not set`)
	assert.True(t, args.Append, `args.Append not set`)
	assert.Equal(t, pre, args.Pre, `args.Pre incorrect`)
	assert.Equal(t, post, args.Post, `args.Post incorrect`)
	assert.Equal(t, comment, args.Cmt, `args.Cmt incorrect`)
	assert.Equal(t, wild, args.Wild, `args.Wild incorrect`)
	assert.Equal(t, pkg, args.Pkg, `args.Pkg incorrect`)
	assert.Zero(t, stdout.String())
	assert.Zero(t, stderr.String())
}
