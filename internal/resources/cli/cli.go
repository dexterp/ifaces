package cli

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/docopt/docopt-go"
)

var usage = `Usage:
  ifaces [<out>] [(-f <src>)...] [-a] [--pre <pre>] [--post <post>] [-c <cmt>] [-p <pkg>] [-m <mtch>] [--struct] [-i <iface>] [--no-tdoc] [--no-fdoc] [--print]

Options:
  -h              Show this screen.
  <out>           Output file. Truncated unless -a is set. 
  -a              Add to output file instead of truncating.
  -c <cmt>        Comment at top of output file. [default: DO NOT EDIT. GENERATED BY ifaces]   
  -f <src>        Source file to scan.
  -i <iface>      Optional interface type name. If omitted the type name is used
                  with a prefix and/or suffix added.
  --no-fdoc       Do not copy function docs to the interface function.
  --no-tdoc       Do not copy typedoc from type.
  -p <pkg>        Package name. Defaults to the parent directory name.
  --post <post>   Add a suffix to interface type name.
  --pre <pre>     Add a prefix to interface type name.
  --print         Print generated source to stdout.
  --struct        Generate an interface for all structs.
  --tdoc <tdoc>   Custom type document. Defaults to the document from the origin
                  source type.
  -m <mtch>       Generate interfaces for types that match a wildcard.
 `

func ParseArgs(argv []string, version string, stdout io.Writer, stderr io.Writer) (*Args, error) {
	var fnerr error
	fn := func(err error, usage string) {
		if len(argv) > 0 && (argv[0] == "-h" || argv[0] == "--help") {
			fmt.Fprintln(stdout, usage)
			os.Exit(0)
		} else {
			fnerr = err
			fmt.Fprint(stderr, err.Error())
			fmt.Fprintln(stderr, `invalid or incomplete options, see "ifaces -h" for cli options`)
		}
	}
	if fnerr != nil {
		return nil, fnerr
	}
	parser := &docopt.Parser{
		HelpHandler: fn,
	}
	args, err := parser.ParseArgs(usage, argv, version)
	if err != nil {
		return nil, err
	}
	config := &Args{}
	err = args.Bind(config)
	if err != nil {
		fmt.Fprintf(stderr, `error binding command arguments: %s`, err.Error())
	}
	err = dynamicPkg(config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

func dynamicPkg(args *Args) error {
	if args.Pkg != `` {
		return nil
	}
	if args.Out == `` {
		return nil
	}
	abs, err := filepath.Abs(args.Out)
	if err != nil {
		return err
	}
	d := filepath.Dir(abs)
	pkg := filepath.Base(d)
	args.Pkg = pkg
	return nil
}

type Args struct {
	Out string `docopt:"<out>"`

	Append bool     `docopt:"-a"`
	Cmt    string   `docopt:"-c"`
	Iface  string   `docopt:"-i"`
	NoFDoc bool     `docopt:"--no-fdoc"`
	NoTDoc bool     `docopt:"--no-tdoc"`
	Pkg    string   `docopt:"-p"`
	Post   string   `docopt:"--post"`
	Pre    string   `docopt:"--pre"`
	Print  bool     `docopt:"--print"`
	Srcs   []string `docopt:"-f"`
	Struct bool     `docopt:"--struct"`
	TDoc   string   `docopt:"--tdoc"`
	Match  string   `docopt:"-m"`
}
