package cli

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/docopt/docopt-go"
)

var usage = `Usage:
  ifaces gen <out> (-f <src>)... [--pre <pre>] [--post <post>] [-c <cmt>] [-p <pkg>] [-w <wild>] [--struct] [--no-tdoc] [--no-fdoc] [--no-hdr] [--print]
  ifaces head <out> [-a] [--pre <pre>] [--post <post>] [-c <cmt>] [-p <pkg>] [-w <wild>] [--struct] [--no-tdoc] [--no-fdoc] [--no-hdr] [--print]
  ifaces entry <out> [--pre <pre>] [--post <post>] [-i <iface>] [--no-tdoc|--tdoc <tdoc>] [--no-fdoc] [--print]

Options:
  -h              Show this screen.
  gen             Generate command. Scan <srcs> for type definitions and
                  generate the corresponding interfaces in the <out> file.
  head            Header command. Adds the package and a comment to top of the
                  generated source. To be used with "go generate".
  entry           Individual interface entry, this should be placed before a
                  type and type comments. To be used with "go generate".
  <out>           Output file. when used with "head", the file is truncated
                  unless -a is set, when used with "entry" the file is appended.
  -a              Append to output file instead of truncating.
  -c <cmt>        Comment at top of output file. [default: DO NOT EDIT. GENERATED BY ifaces]   
  -f <src>        Source file to scan.
  -i <iface>      Optional interface type name. If omitted the type name is used
                  with a prefix and/or suffix added.
  --no-fdoc       Do not copy function docs to the interface function.
  --no-hdr        Do not generate the source header.
  --no-tdoc       Do not copy typedoc from type.
  -p <pkg>        Package name. Defaults to the parent directory name.
  --post <post>   Add a suffix to interface type name.
  --pre <pre>     Add a prefix to interface type name.
  --print         Print generated source to stdout.
  --struct        Generate an interface for all structs.
  --tdoc <tdoc>   Custom type document. Defaults to the document from the origin
                  source type.
  -w <wild>       generate interfaces for types that match a wildcard.
 `

func ParseArgs(argv []string, version string, stdout io.Writer, stderr io.Writer) (*Args, error) {
	var fnerr error
	fn := func(err error, usage string) {
		if len(argv) > 0 && (argv[0] == "-h" || argv[0] == "--help") {
			fmt.Fprintln(stdout, usage)
			os.Exit(0)
		} else {
			fnerr = err
			fmt.Fprint(stderr, err.Error())
			fmt.Fprintln(stderr, `invalid or incomplete options, see "ifaces -h" for cli options`)
		}
	}
	if fnerr != nil {
		return nil, fnerr
	}
	parser := &docopt.Parser{
		HelpHandler: fn,
	}
	args, err := parser.ParseArgs(usage, argv, version)
	if err != nil {
		return nil, err
	}
	config := &Args{}
	err = args.Bind(config)
	if err != nil {
		fmt.Fprintf(stderr, `error binding command arguments: %s`, err.Error())
	}
	err = dynamicPkg(config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

func dynamicPkg(args *Args) error {
	if args.Pkg != `` {
		return nil
	}
	if args.Out == `` {
		return nil
	}
	abs, err := filepath.Abs(args.Out)
	if err != nil {
		return err
	}
	d := filepath.Dir(abs)
	pkg := filepath.Base(d)
	args.Pkg = pkg
	return nil
}

type Args struct {
	Gen   bool   `docopt:"gen"`
	Head  bool   `docopt:"head"`
	Entry bool   `docopt:"entry"`
	Out   string `docopt:"<out>"`

	Append bool     `docopt:"-a"`
	Cmt    string   `docopt:"-c"`
	Iface  string   `docopt:"-i"`
	NoFDoc bool     `docopt:"--no-fdoc"`
	NoHdr  bool     `docopt:"--no-hdr"`
	NoTDoc bool     `docopt:"--no-tdoc"`
	Pkg    string   `docopt:"-p"`
	Post   string   `docopt:"--post"`
	Pre    string   `docopt:"--pre"`
	Print  bool     `docopt:"--print"`
	Srcs   []string `docopt:"-f"`
	Struct bool     `docopt:"--struct"`
	TDoc   string   `docopt:"--tdoc"`
	Wild   string   `docopt:"-w"`
}
